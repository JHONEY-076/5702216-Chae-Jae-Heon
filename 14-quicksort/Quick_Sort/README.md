Quick Sort(재귀적 방법)

![](https://github.com/JHONEY-076/5702216-Chae-Jae-Heon/blob/master/14-quicksort/Quick_Sort/Quick_%EB%B0%98%EB%B3%B5%EC%A0%81_%EB%B0%A9%EB%B2%95.jpg)





Quick Sort(반복적 방법)

![](
https://github.com/JHONEY-076/5702216-Chae-Jae-Heon/blob/master/14-quicksort/Quick_Sort/Quick_%EC%9E%AC%EA%B7%80%EC%A0%81_%EB%B0%A9%EB%B2%95.jpg)



- 이전 정렬방법(선택, 삽입, 버블, 쉘, 합병)과 성능 비교 설명-

1. 선택 정렬
   - 시간 복잡도:O(n²)의 시간 복잡도를 가지고 있으며, 최선, 최악,평균의 경우에도 동일한 시간 복잡도를 가진다.
   - 퀵정렬과의 비교: 퀵정렬의 평균 시간 복잡는 O(n log n)으로 선택 정렬보다 빠르다는 특징이 있고, 이로 인해 선택 정렬은 작은 데이터 그룹에서 유용할 수는 있지만, 퀵 정렬은 큰 데이터 그룹에서 훨씬 뛰어난 성능을 보임을 알 수 있다.
  
2. 삽입 정렬
  - 시간 복잡도: 최선: O(n)=> 데이터가 거의 정렬된 상태 , 평균,최악=> O(n²)
  - 퀵정렬과의 비교: 퀵정렬은 평균적으로 삽입 정렬보다 빠르며, 데이터가 거의 정렬된 상태인 최선의 경우에도 퀵정렬이 삽입 정렬보다 성능이 뛰어나다는것을 알 수 있다. 하지만 이전의 선택정렬과 같이 작은 데이터 그룹에서는 삽입 정렬이 성능상 유리할 수 있다.

3. 버블 정렬
   -시간 복잡도: 최선=>O(n), 최악,평균=> O(n²)
   -퀵정렬과의 비교: 퀵 정렬이 버블 정렬보다 훨씬 성능이 좋다는것을 알수 있고 ,버블 정렬은 인접한 요소들을 비교하는 방식으로 최선의 경우 O(n)으로 퀵정렬 보다 훨씬 성능이 떨어지는것을 볼 수 있다.  특히 데이터 그룹이 클 경우 성능이 많이 차이가 나는것을 알 수 있다.

4. 쉘 정렬
   -시간 복잡도: 최선 O(n log n), 평균 O(n^(3/2)), 최악 O(n²)
   -퀵정렬과의 비교: 쉘 정렬은 최선과 최악의 경우로는 O(n log n),O(n²)으로 같지만 평균의 경우를 살펴보면  O(n^(3/2))의 시간 복잡도를 가지고, 성능이 평균적으로 퀵정렬에는 미치지 못한다. 그러나 작은 데이터 그룹에서는 퀵정렬 보다 효과적일 수 있다.

5. 합병 정렬
   -시간 복잡도: 최선, 평균 ,최악=> O(n log n)
   -퀵 정렬과의 비교: 합병 정렬은 최악의 경우에도 O(n log n)의 성능을 보장하므로 퀵정렬의 최악의 경우일때 O(n²)보다 시간복잡도가 작다는 볼 수 있다. 하지만 퀵정렬은 평균적으로 더 빠르며, 추가적인 메모리 공간을 사용하는 합병정렬에 비해 공간 효율성이 좋아 메모리 측명에서는 퀵정렬이 우수하다라는것을 알 수 있다.

6. 퀵 정렬
  - 시간 복잡도 : 평균,최선: O(n log n), 최악:O(n²)
  - 특징: 평균적으로 빠르며, 평균과 최선의 경우 대부분 O(n log n)의 시간 복잡성을 가지고 있으며, 최악의 경우 O(n²)의 시간 복잡도를 가질 수 있다. 

